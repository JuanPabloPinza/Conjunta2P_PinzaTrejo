# Sistema de Monitoreo Distribuido para Atenci√≥n M√©dica en Tiempo Real

*Sistema escalable para monitorear signos vitales de pacientes en tiempo real usando una arquitectura de microservicios, cumpliendo con los requisitos de la materia de Aplicaciones Distribuidas.*

**Integrantes:** Juan Pablo Pinza, Alex Trejo

---

### Arquitectura de Microservicios

El sistema est√° compuesto por los siguientes microservicios, cada uno con un prop√≥sito claramente definido:

| Servicio | Puerto (Host) | Service ID (Eureka) | Descripci√≥n |
| :--- | :--- | :--- | :--- |
| **ms-api-gateway** | `8000` | `API-GATEWAY` | Punto de entrada √∫nico para todas las peticiones, gestiona el enrutamiento y el balanceo de carga. |
| **ms-eureka-server** | `8761` | N/A | Servidor de descubrimiento. Mantiene un registro de todas las instancias de microservicios activas. |
| **patient-data-collector** | `0` (aleatorio) | `PATIENT-DATA-COLLECTOR`| Recibe y almacena datos brutos de signos vitales desde dispositivos IoT y publica los eventos. |
| **health-analyzer** | `0` (aleatorio) | `HEALTH-ANALYZER` | Escucha los eventos de signos vitales, aplica reglas de negocio, genera alertas y reportes. |
| **care-notifier** | `0` (aleatorio) | `CARE-NOTIFIER` | Escucha las alertas y reportes, y simula el env√≠o de notificaciones a personal m√©dico. |

---

## üíª Requisitos Previos

Antes de instalar el proyecto, aseg√∫rate de tener instalado:

- **Java JDK 17** o superior.
  ```bash
  java --version
  ```
- **Apache Maven**
  ```bash
  mvn --version
  ```
- **Docker y Docker Compose**
  ```bash
  docker --version
  docker compose version
  ```
- **Git**
  ```bash
  git --version
  ```
- Un cliente de base de datos para PostgreSQL (como DBeaver, pgAdmin, o `psql`) para configurar la base de datos de resiliencia.

---

## üì¶ Instalaci√≥n

1.  **Clonar el Repositorio**
    ```bash
    git clone https://github.com/JuanPabloPinza/Conjunta2P_PinzaTrejo.git
    cd Conjunta2P_PinzaTrejo
    ```

2.  **Construir el Proyecto con Maven**
    Este comando compilar√° todos los m√≥dulos y descargar√° las dependencias necesarias. Ejec√∫talo desde la carpeta ra√≠z del proyecto.
    ```bash
    mvn clean install
    ```

---

## ‚öôÔ∏è Configuraci√≥n y Ejecuci√≥n

La ejecuci√≥n del proyecto se realiza en 3 pasos: levantar la infraestructura, preparar las bases de datos y finalmente, iniciar los microservicios.

### Paso 1: Levantar la Infraestructura con Docker

El archivo `docker-compose.yml` en la ra√≠z del proyecto levantar√° todos los servicios de infraestructura necesarios:
- **RabbitMQ**: Broker de mensajer√≠a (UI en `http://localhost:15672`).
- **CockroachDB Cluster**: Base de datos distribuida de 3 nodos (UI en `http://localhost:8080`).

Para iniciar todo, ejecuta el siguiente comando desde la ra√≠z del proyecto:
```bash
docker compose up -d
```
Espera uno o dos minutos para que todos los contenedores se inicien y estabilicen. Puedes verificar el estado con `docker ps`.

### Paso 2: Preparar las Bases de Datos (Paso Manual Obligatorio)

**Raz√≥n:** Debido a la complejidad de una configuraci√≥n multi-datasource en Spring Boot, la generaci√≥n autom√°tica de tablas (`hibernate.ddl-auto: update`) no se aplica de forma fiable a las bases de datos secundarias. Para garantizar la consistencia y el correcto funcionamiento, la creaci√≥n de todas las tablas se debe realizar manualmente.

#### a) Preparar Base de Datos de Resiliencia (PostgreSQL Local)

1.  Aseg√∫rate de tener una instancia de PostgreSQL corriendo en tu m√°quina local.
2.  Con√©ctate a tu PostgreSQL y crea las bases de datos para cada microservicio que usa resiliencia:
    ```sql
    CREATE DATABASE resilience_db_collector;
    CREATE DATABASE resilience_db_analyzer;
    CREATE DATABASE resilience_db_notifier;
    ```
3.  Ejecuta los siguientes scripts SQL **en cada base de datos correspondiente**:

    **En `resilience_db_collector` y `resilience_db_analyzer`:**
    ```sql
    CREATE TABLE IF NOT EXISTS pending_events (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        event_json TEXT NOT NULL,
        exchange_name VARCHAR(255) NOT NULL,
        routing_key VARCHAR(255) NOT NULL,
        retry_count INT NOT NULL DEFAULT 0,
        created_at TIMESTAMP WITH TIME ZONE NOT NULL
    );
    ```

    **En `resilience_db_notifier`:**
    ```sql
    CREATE TABLE IF NOT EXISTS pending_notifications (
        id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
        recipient VARCHAR(255) NOT NULL,
        subject VARCHAR(255) NOT NULL,
        body TEXT NOT NULL,
        channel VARCHAR(50) NOT NULL,
        retry_count INT NOT NULL DEFAULT 0,
        created_at TIMESTAMP WITH TIME ZONE NOT NULL
    );
    ```

#### b) Preparar Base de Datos Principal (CockroachDB)

1.  Con√©ctate a tu cl√∫ster de CockroachDB (ej. a trav√©s de la UI en `http://localhost:8080` o usando `docker exec -it crdb-node1 ./cockroach sql --insecure`).
2.  Ejecuta los siguientes comandos para crear las bases de datos y sus tablas:

    ```sql
    -- Primero, crea las bases de datos
    CREATE DATABASE IF NOT EXISTS db_patient_data;
    CREATE DATABASE IF NOT EXISTS db_health_alerts;
    CREATE DATABASE IF NOT EXISTS db_notifications;

    -- Tablas para db_patient_data
    USE db_patient_data;
    CREATE TABLE IF NOT EXISTS vital_signs (
        id BIGINT PRIMARY KEY DEFAULT unique_rowid(),
        device_id VARCHAR(255) NOT NULL,
        type VARCHAR(255) NOT NULL,
        value FLOAT NOT NULL,
        "timestamp" TIMESTAMPTZ NOT NULL
    );

    -- Tablas para db_health_alerts
    USE db_health_alerts;
    CREATE TABLE IF NOT EXISTS medical_alerts (
        alert_id VARCHAR(255) PRIMARY KEY,
        type VARCHAR(255) NOT NULL,
        device_id VARCHAR(255) NOT NULL,
        value FLOAT NOT NULL,
        threshold FLOAT,
        "timestamp" TIMESTAMPTZ NOT NULL
    );
    CREATE TABLE IF NOT EXISTS device_last_seen (
        device_id VARCHAR(255) PRIMARY KEY,
        last_seen_timestamp TIMESTAMPTZ NOT NULL
    );
    CREATE TABLE IF NOT EXISTS vital_sign_records (
        id BIGINT PRIMARY KEY DEFAULT unique_rowid(),
        event_id VARCHAR(255) NOT NULL UNIQUE,
        device_id VARCHAR(255) NOT NULL,
        type VARCHAR(255) NOT NULL,
        value FLOAT NOT NULL,
        "timestamp" TIMESTAMPTZ NOT NULL,
        received_at TIMESTAMPTZ NOT NULL
    );

    -- Tabla para db_notifications
    USE db_notifications;
    CREATE TABLE IF NOT EXISTS notifications (
        notification_id VARCHAR(255) PRIMARY KEY,
        event_type VARCHAR(255) NOT NULL,
        recipient VARCHAR(255) NOT NULL,
        status VARCHAR(50) NOT NULL,
        "timestamp" TIMESTAMPTZ NOT NULL
    );
    ```

### Paso 3: Ejecutar los Microservicios

Con la infraestructura y las bases de datos listas, ahora puedes iniciar las aplicaciones de Spring Boot desde tu IDE.

Inicia los servicios en el siguiente orden:
1.  `ms-eureka-server`
2.  `ms-api-gateway`
3.  `patient-data-collector`
4.  `health-analyzer`
5.  `care-notifier`

---

## üöÄ Uso y Pruebas del Sistema

### Tipos de Signos Vitales (`type`)

Para enviar datos, el campo `type` debe ser uno de los siguientes valores:
- `"heart-rate"`
- `"oxygen-level"`
- `"blood-pressure-systolic"`
- `"blood-pressure-diastolic"`

### Ejemplo de Prueba: Enviar un Signo Vital

Usa `curl` o Postman para enviar una petici√≥n `POST` al API Gateway.

**URL:** `http://localhost:8000/conjunta/2p/collector/vital-signs`

**Cuerpo (para generar una alerta de emergencia):**
```json
{
  "deviceId": "D-EMG-001",
  "type": "heart-rate",
  "value": 160,
  "timestamp": "2025-07-09T20:00:00Z"
}
```

### Flujo de Notificaciones y Priorizaci√≥n

El `CareNotifier` clasifica las alertas recibidas en tres niveles: `EMERGENCY`, `WARNING`, y `INFO`.

- **EMERGENCY**:
    - **Disparadores:** `CriticalHeartRateAlert`, `OxygenLevelCritical`, `HighBloodPressureAlert`.
    - **Acci√≥n:** Se env√≠an notificaciones **inmediatamente** a trav√©s de todos los canales simulados (Email, SMS, Push).
- **WARNING / INFO**:
    - **Disparadores:** `DeviceOfflineAlert` (Warning), reportes diarios (Info), y otras alertas no cr√≠ticas.
    - **Acci√≥n:** Las notificaciones se agrupan en una cola. Una tarea programada las env√≠a todas juntas en un **resumen por correo electr√≥nico cada 30 minutos** (o seg√∫n se configure para pruebas).

---

### Configuraci√≥n de Tareas Programadas (Modo de Prueba vs. Producci√≥n)

Los archivos `application.yml` de `HealthAnalyzer` y `CareNotifier` contienen una secci√≥n `tasks` para configurar la frecuencia de las tareas programadas.

#### Configuraci√≥n para Pruebas (R√°pida)

Para ver las tareas ejecutarse r√°pidamente durante la demostraci√≥n, puedes usar esta configuraci√≥n en los `application.yml` correspondientes:

**`health-analyzer/application.yml`:**
```yaml
tasks:
  inactive-check:
    rate: 60000          # Cada minuto
  daily-report:
    cron: "0 */1 * * * *" # Cada minuto
  cleanup-old-data:
    cron: "0 */5 * * * *" # Cada 5 minutos
```

**`care-notifier/application.yml`:**
```yaml
tasks:
  batch-sending:
    rate: 60000           # Cada minuto
  resilience-retry:
    rate: 30000           # Cada 30 segundos
```

#### Configuraci√≥n para Producci√≥n (Seg√∫n especificaci√≥n del documento)

Para un despliegue real, se deben usar los valores especificados en el documento:

**`health-analyzer/application.yml`:**
```yaml
tasks:
  inactive-check:
    rate: 21600000        # Cada 6 horas
  daily-report:
    cron: "0 0 4 * * *"    # Cada 24 horas (a las 4 AM)
  cleanup-old-data:
    cron: "0 0 5 1 * *"    # Mensualmente (d√≠a 1 a las 5 AM)```
```
**`care-notifier/application.yml`:**
```yaml
tasks:
  batch-sending:
    rate: 1800000         # Cada 30 minutos
  resilience-retry:
    rate: 30000           # Cada 30 segundos (puede mantenerse as√≠)
```

---

## üõ†Ô∏è Tecnolog√≠as Utilizadas

- **Backend:** Spring Boot, Spring Cloud (Gateway, Eureka), Spring Data JPA, Spring AMQP
- **Lenguaje:** Java 17
- **Base de Datos Principal:** CockroachDB (Cl√∫ster Distribuido)
- **Base de Datos de Resiliencia:** PostgreSQL
- **Mensajer√≠a:** RabbitMQ
- **DevOps:** Docker, Docker Compose, Maven